[{"title":"如何在ubuntu22.04下安装ros_noetic","path":"/2024/10/29/如何在ubuntu22-04下安装ros-noetic/","content":"前言由于之前已经了 Ubuntu 22.04 LTS Jammy 双系统，想装 ros noetic，但发现 ros noetic 的 release 只支持到 20.04，所以就想自己从源码构建一个。但是，装完发现 autolabor 官方已经编译了一个 ros noetic ninjemys 安装包，按照以下步骤直接安装即可 使用 autolabor 官方的安装包添加源1echo &quot;deb [trusted=yes arch=amd64] http://deb.repo.autolabor.com.cn jammy main&quot; | sudo tee /etc/apt/sources.list.d/autolabor.list 更新源1sudo apt update 安装网不好可能需要多试几次 1sudo apt install ros-noetic-autolabor 就这样，简简单单。以下手动构建的内容权当娱乐&gt;_&lt; 从源码构建基础准备首先我们需要安装如下基础软件包来确保后面步骤的正常进行： 1sudo apt install git gnupg wget 安装构建依赖的工具首先添加 packages.ros.org 作为软件提供者 12345sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu focal main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -sudo apt update 然后安装构建所需要的依赖工具 1sudo apt-get install python3-rosdep python3-rosinstall-generator python3-vcstools python3-vcstool build-essential 安装完成后，我们就可以初始化 ros 的依赖管理工具了 1sudo rosdep init 安装 hddtemp¿虽然很神奇，但是我们确实需要为为 Ubuntu 22.04 安装 hddtemp。推测是 ros 需要 hddtemp 但是在 22.04 这个被移除了。 12345cd ~/Downloadswget http://archive.ubuntu.com/ubuntu/pool/universe/h/hddtemp/hddtemp_0.3-beta15-53_amd64.debsudo apt install ~/Downloads/hddtemp_0.3-beta15-53_amd64.deb 然后我们需要让 rosdeb 知道你本地已经有 hddtemp 了，为此，我们需要让 ros 读取本地修改过的 base.yaml 文件而不是让它直接从仓库拉取。我们首先需要拉下来一个 base.yaml 来修改 123cd ~/Downloadswget https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/base.yaml 然后打开下载的 base.yaml 文件，在 hddtemp 部分添加 jammy： [hddtemp] 。修改之后文件的 hddtemp 部分应如下所示（注意最后一行）： 123456789101112131415161718hddtemp: arch: [hddtemp] debian: [hddtemp] fedora: [hddtemp] freebsd: [python27] gentoo: [app-admin/hddtemp] macports: [python27] nixos: [hddtemp] openembedded: [hddtemp@meta-oe] opensuse: [hddtemp] rhel: [hddtemp] slackware: [hddtemp] ubuntu: &quot;*&quot;: null bionic: [hddtemp] focal: [hddtemp] impish: [hddtemp] jammy: [hddtemp] 最后只需要让 rosdep 读取本地的 base.yaml 文件就可以了先下载 ros 的 default.list 1sudo gedit /etc/ros/rosdep/sources.list.d/20-default.list 修改本地的 default.list 文件 1vim /etc/ros/rosdep/sources.list.d/20-default.list 只需修改你的用户名为你的用户名（？），当然，如果你把 base.yaml 放在了别处就修改整个地址为你 base.yaml 的位置就行 1234567891011# os-specific listings firstyaml https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/osx-homebrew.yaml osx# generic#yaml https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/base.yamlyaml file:///home/你的用户名/Downloads/base.yamlyaml https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/python.yamlyaml https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/ruby.yamlgbpdistro https://raw.githubusercontent.com/ros/rosdistro/master/releases/fuerte.yaml fuerte# newer distributions (Groovy, Hydro, ...) must not be listed anymore, they are being fetched from the rosdistro index.yaml instead 最后刷新 rosdep 即可 1rosdep update 下载 ROS 包的依赖项创建一个文件夹来临时存放源码 123mkdir ~/ros_catkin_wscd ~/ros_catkin_ws 下载 ros-noetic-desktop-full 的源代码 12345rosinstall_generator desktop --rosdistro noetic --deps --tar &gt; noetic-desktop.rosinstallmkdir ./srcvcs import --input noetic-desktop.rosinstall ./src 然后安装所有这些 ROS 包的依赖项，大抵是需要等一会 1rosdep install --from-paths ./src --ignore-packages-from-source --rosdistro noetic -y 小修一下原版的包原版的 ros 有两个包（rosconsole 和 urdf）与 Ubuntu 22.04 不兼容但是 github 上已经有解决方案了！感谢大佬们！ 先备份一下原版的文件，免得修坏了 12345cd ~/ros_catkin_ws/srcmkdir ~/Downloads/backupmv rosconsole urdf ~/Downloads/backup/ 拉取 github 上兼容的的 rosconsole 和 urdf 包 1234567git clone https://github.com/dreuter/rosconsole.gitcd rosconsolegit checkout noetic-jammycd ~/ros_catkin_ws/src 1234567git clone https://github.com/dreuter/urdf.gitcd urdfgit checkout set-cxx-versioncd ~/ros_catkin_ws/src 安装！终于，可以安装了以下命令是将其默认安装在~/ros_catkin_ws/install_isolated这个位置。当然，你可以添加--install-space /opt/ros/noetic参数来让 ros 安装在/opt/ros/noetic 位置，也就是其在 20.04 上的默认位置ros 会构建它所需要的包，这大抵还是需要一些时间 123cd ~/ros_catkin_ws./src/catkin/bin/catkin_make_isolated --install -DCMAKE_BUILD_TYPE=Release 大功告成如果一切顺利，ros 应该是被成功安装了，你可以使用如下命令启动 roscore 来验证 123source ~/ros_catkin_ws/install_isolated/setup.bashroscore 看到末尾有started core service [/rosout]就是成功启动了 为了使你的 ros 命令添加在环境变量中，不用每次都 source，你可以 1vim ~/.bashrc 在文件末尾加上 1source ~/ros_catkin_ws/install_isolated/setup.bash 收工！","tags":["ros"]},{"title":"第一次题解","path":"/2024/10/24/第一次题解/","content":"「安恒杯」第二届 NEX 网络安全理论赛 WP 共解出 8 题 COMMON【简单】签到喵确实简单，海报下方…. …– .—- .. — ..–.- .– — .-. .—- -..摩斯电码，解码后为 H31IO_WOR1D，提交即可。（说实话第一次知道下划线怎么打） 然后，就没有 common 了。。QAQ MATH【简单】凯撒超进化Vigenère cipher，这次 geekgame 也有，两种方法，一是查表，但说实话不如利用其特性可以根据 nex 这个前缀手动试出来 key 为 ozu。 【中等】2024 爱护你的蟒蛇打开 round1.py，发现储存 flag 的部分： 1234567enc = [……]def check_flag(text): text = list(text) for i in range(len(text)): text[i] = (ord(text[i]) ^ 0xCC) - 3 return text == enc 写出其的逆过程： 12345def de_flag(enc): text = &quot;&quot; for i in range(len(enc)): text += chr((enc[i] + 3) ^ 0xCC) return text 运行得 flag。 也没了！菜死了我。 PWN【简单】浮屠塔的出口nc 连上之后走个迷宫就没了。 PWN 就这一题，其他的题本地打通了，然后忘了 :P BINARY【简单】从零开始的 CPP 生活我不好说，但是。。。我之前为了正好装过 vs，直接打开，vs 帮我做完了。打开 flag.cpp 后： 123456789#include &quot;flag.hpp&quot;Flag::Flag() &#123;\tflag = &quot;flag&#123;b9bcd94c-2ee1-4e74-b8e2-372a10869adc&#125;&quot;;&#125;std::string Flag::GetFlag()&#123;\treturn this-&gt;flag;&#125; 【中等】开源逆向题喵打开程序，发现被挡住了，但是背景是像素字！然后看文件，一个醒目的 flag.h，一打开，发现 1int flag_pixels[360][480] = &#123;……&#125; 欸，合理怀疑就是背景 flag 图片，写转为 png 脚本： 12345678from PIL import Imageimport numpy as npflag_pixels = [……]array = np.array(flag_pixels, dtype=np.uint8)img = Image.fromarray(array * 255, mode=&#x27;L&#x27;)img.show() 完事，感觉不像预期解，但是有没防，怪。 【简单】假面之下的 Flag呃呃，拖进 ida -&gt; shift+F12 查看字串 -&gt; 甚至第一个就是。 【困难】愤怒喵 NaN~我测，我一拖进 ida，main 函数那图一出来，我去，吓人。还是 shift+F12 查看字串起手，发现两终点： 12.rodata:000000000000B016\t00000007\tC\tN0N0N0.rodata:000000000000B010\t00000006\tC\tG00D! 可以写出判断终点函数： 12345def is_success(state): return b&#x27;G00D!&#x27; in state.posix.dumps(sys.stdout.fileno())def is_fail(state): return b&#x27;N0N0N0&#x27; in state.posix.dumps(sys.stdout.fileno()) 这样不用记地址。按 f5 反编分析 main 函数，发现以下语句： 12stream = fopen(&quot;flag.png&quot;, &quot;rb&quot;);fread(&amp;ptr, 1uLL, 0x142uLL, stream); 说明读入了一个大小为 0x142 的 flag.png，可以在 angr 中模拟文件系统，创建一个 flag.png 的符号执行对象： 123file_size = 0x142symbolic_file = angr.storage.SimFile(&quot;flag.png&quot;, size=file_size)initial_state.fs.insert(&quot;flag.png&quot;, symbolic_file) 然后，跑就完事了！ 12345678910111213141516171819202122232425262728293031323334353637import angrimport sysfrom PIL import Imageimport iodef Go(): path_to_binary = &quot;./mustangr/problem&quot; project = angr.Project(path_to_binary) initial_state = project.factory.entry_state() file_size = 0x142 symbolic_file = angr.storage.SimFile(&quot;flag.png&quot;, size=file_size) initial_state.fs.insert(&quot;flag.png&quot;, symbolic_file) simulation = project.factory.simgr(initial_state) def is_success(state): return b&#x27;G00D!&#x27; in state.posix.dumps(sys.stdout.fileno()) def is_fail(state): return b&#x27;N0N0N0&#x27; in state.posix.dumps(sys.stdout.fileno()) simulation.explore(find=is_success, avoid=is_fail) if simulation.found: solution_state = simulation.found[0] flag_content = solution_state.fs.get(&quot;flag.png&quot;).concretize() print(&quot;[+] Success! The flag content is: &#123;&#125;&quot;.format(flag_content)) image = Image.open(io.BytesIO(flag_content)) image.save(&quot;output.png&quot;) else: print(&quot;[-] Could not find the solution&quot;)if __name__ == &quot;__main__&quot;: Go() 其实 vmp 那题我也在尝试，已经打了很多函数了，但确实时间不够，没把逻辑看完 QAQ。 小结感谢 NEX 奇妙の小题。","tags":["ctf"]}]