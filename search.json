[{"title":"Bilibili 评论区钓鱼链接","path":"/2026/02/21/bilibili评论区钓鱼链接/","content":"前言最近群友偶然提到在 B 站发现一种挂羊头卖狗肉的链接，具体表现为链接显示的是一个视频的标题，但是点进去实际跳转播放的是另一个视频（结合日期，你应该能想到是什么视频）。 现象分析检查渲染出来的链接如下： a style=--icon-width:1.2em;--icon-height:1.2em; href=//www.bilibili.com/video/BV1xxxxxxxxx/../BV2xxxxxxxxx target=_blank data-type=linkimg src=https://i0.hdslb.com/bfs/static/placeholder.png loading=lazy style=width:var(--icon-width);height:var(--icon-height);vertical-align:var(--icon-vertical-align); 可以看到链接的 href 属性中有一个 ../，典型的路径穿越。浏览器在解析链接时会将 ../ 解析为上一级目录，从而导致实际跳转的 URL 与预期不符。 复现和新问题基于这个发现，我尝试在评论区复现这个现象。输入： https://www.bilibili.com/video/BV1/../BV2 发现 B 站把前后两个 BV 号分别解析了，而 ../ 没有被当成一个整体被处理。这不是我想要的。 一点绕过自然而然的，我们想到了 URL 编码绕过。不明文表示 ../，而是使用对应编码来替换，即 %2E%2E/，用来绕过相关的正则检查，并且也能被浏览器正确解析。 输入 https://www.bilibili.com/video/BV1/%2E%2E/BV2 能复现出相同的效果。 以上。","tags":["Security"]},{"title":"如何在ubuntu22.04下安装ros_noetic","path":"/2024/10/29/如何在ubuntu22-04下安装ros-noetic/","content":"前言由于之前已经了 Ubuntu 22.04 LTS Jammy 双系统，想装 ros noetic，但发现 ros noetic 的 release 只支持到 20.04，所以就想自己从源码构建一个。但是，装完发现 autolabor 官方已经编译了一个 ros noetic ninjemys 安装包，按照以下步骤直接安装即可 使用 autolabor 官方的安装包添加源echo deb [trusted=yes arch=amd64] http://deb.repo.autolabor.com.cn jammy main | sudo tee /etc/apt/sources.list.d/autolabor.list 更新源sudo apt update 安装网不好可能需要多试几次 sudo apt install ros-noetic-autolabor 就这样，简简单单。以下手动构建的内容权当娱乐_ 从源码构建基础准备首先我们需要安装如下基础软件包来确保后面步骤的正常进行： sudo apt install git gnupg wget 安装构建依赖的工具首先添加 packages.ros.org 作为软件提供者 sudo sh -c echo deb http://packages.ros.org/ros/ubuntu focal main /etc/apt/sources.list.d/ros-latest.listcurl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -sudo apt update 然后安装构建所需要的依赖工具 sudo apt-get install python3-rosdep python3-rosinstall-generator python3-vcstools python3-vcstool build-essential 安装完成后，我们就可以初始化 ros 的依赖管理工具了 sudo rosdep init 安装 hddtemp¿虽然很神奇，但是我们确实需要为为 Ubuntu 22.04 安装 hddtemp。推测是 ros 需要 hddtemp 但是在 22.04 这个被移除了。 cd ~/Downloadswget http://archive.ubuntu.com/ubuntu/pool/universe/h/hddtemp/hddtemp_0.3-beta15-53_amd64.debsudo apt install ~/Downloads/hddtemp_0.3-beta15-53_amd64.deb 然后我们需要让 rosdeb 知道你本地已经有 hddtemp 了，为此，我们需要让 ros 读取本地修改过的 base.yaml 文件而不是让它直接从仓库拉取。我们首先需要拉下来一个 base.yaml 来修改 cd ~/Downloadswget https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/base.yaml 然后打开下载的 base.yaml 文件，在 hddtemp 部分添加 jammy： [hddtemp] 。修改之后文件的 hddtemp 部分应如下所示（注意最后一行）： hddtemp: arch: [hddtemp] debian: [hddtemp] fedora: [hddtemp] freebsd: [python27] gentoo: [app-admin/hddtemp] macports: [python27] nixos: [hddtemp] openembedded: [hddtemp@meta-oe] opensuse: [hddtemp] rhel: [hddtemp] slackware: [hddtemp] ubuntu: *: null bionic: [hddtemp] focal: [hddtemp] impish: [hddtemp] jammy: [hddtemp] 最后只需要让 rosdep 读取本地的 base.yaml 文件就可以了先下载 ros 的 default.list sudo gedit /etc/ros/rosdep/sources.list.d/20-default.list 修改本地的 default.list 文件 vim /etc/ros/rosdep/sources.list.d/20-default.list 只需修改你的用户名为你的用户名（？），当然，如果你把 base.yaml 放在了别处就修改整个地址为你 base.yaml 的位置就行 # os-specific listings firstyaml https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/osx-homebrew.yaml osx# generic#yaml https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/base.yamlyaml file:///home/你的用户名/Downloads/base.yamlyaml https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/python.yamlyaml https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/ruby.yamlgbpdistro https://raw.githubusercontent.com/ros/rosdistro/master/releases/fuerte.yaml fuerte# newer distributions (Groovy, Hydro, ...) must not be listed anymore, they are being fetched from the rosdistro index.yaml instead 最后刷新 rosdep 即可 rosdep update 下载 ROS 包的依赖项创建一个文件夹来临时存放源码 mkdir ~/ros_catkin_wscd ~/ros_catkin_ws 下载 ros-noetic-desktop-full 的源代码 rosinstall_generator desktop --rosdistro noetic --deps --tar noetic-desktop.rosinstallmkdir ./srcvcs import --input noetic-desktop.rosinstall ./src 然后安装所有这些 ROS 包的依赖项，大抵是需要等一会 rosdep install --from-paths ./src --ignore-packages-from-source --rosdistro noetic -y 小修一下原版的包原版的 ros 有两个包（rosconsole 和 urdf）与 Ubuntu 22.04 不兼容但是 github 上已经有解决方案了！感谢大佬们！ 先备份一下原版的文件，免得修坏了 cd ~/ros_catkin_ws/srcmkdir ~/Downloads/backupmv rosconsole urdf ~/Downloads/backup/ 拉取 github 上兼容的的 rosconsole 和 urdf 包 git clone https://github.com/dreuter/rosconsole.gitcd rosconsolegit checkout noetic-jammycd ~/ros_catkin_ws/src git clone https://github.com/dreuter/urdf.gitcd urdfgit checkout set-cxx-versioncd ~/ros_catkin_ws/src 安装！终于，可以安装了以下命令是将其默认安装在~/ros_catkin_ws/install_isolated这个位置。当然，你可以添加--install-space /opt/ros/noetic参数来让 ros 安装在/opt/ros/noetic 位置，也就是其在 20.04 上的默认位置ros 会构建它所需要的包，这大抵还是需要一些时间 cd ~/ros_catkin_ws./src/catkin/bin/catkin_make_isolated --install -DCMAKE_BUILD_TYPE=Release 大功告成如果一切顺利，ros 应该是被成功安装了，你可以使用如下命令启动 roscore 来验证 source ~/ros_catkin_ws/install_isolated/setup.bashroscore 看到末尾有started core service [/rosout]就是成功启动了 为了使你的 ros 命令添加在环境变量中，不用每次都 source，你可以 vim ~/.bashrc 在文件末尾加上 source ~/ros_catkin_ws/install_isolated/setup.bash 收工！","tags":["ros"]},{"title":"第一次题解","path":"/2024/10/24/第一次题解/","content":"「安恒杯」第二届 NEX 网络安全理论赛 WP 共解出 8 题 COMMON【简单】签到喵确实简单，海报下方…. …– .—- .. — ..–.- .– — .-. .—- -..摩斯电码，解码后为 H31IO_WOR1D，提交即可。（说实话第一次知道下划线怎么打） 然后，就没有 common 了。。QAQ MATH【简单】凯撒超进化Vigenère cipher，这次 geekgame 也有，两种方法，一是查表，但说实话不如利用其特性可以根据 nex 这个前缀手动试出来 key 为 ozu。 【中等】2024 爱护你的蟒蛇打开 round1.py，发现储存 flag 的部分： enc = [……]def check_flag(text): text = list(text) for i in range(len(text)): text[i] = (ord(text[i]) ^ 0xCC) - 3 return text == enc 写出其的逆过程： def de_flag(enc): text = for i in range(len(enc)): text += chr((enc[i] + 3) ^ 0xCC) return text 运行得 flag。 也没了！菜死了我。 PWN【简单】浮屠塔的出口nc 连上之后走个迷宫就没了。 PWN 就这一题，其他的题本地打通了，然后忘了 :P BINARY【简单】从零开始的 CPP 生活我不好说，但是。。。我之前为了正好装过 vs，直接打开，vs 帮我做完了。打开 flag.cpp 后： #include flag.hppFlag::Flag() flag = flagb9bcd94c-2ee1-4e74-b8e2-372a10869adc;std::string Flag::GetFlag()\treturn this-flag; 【中等】开源逆向题喵打开程序，发现被挡住了，但是背景是像素字！然后看文件，一个醒目的 flag.h，一打开，发现 int flag_pixels[360][480] = …… 欸，合理怀疑就是背景 flag 图片，写转为 png 脚本： from PIL import Imageimport numpy as npflag_pixels = [……]array = np.array(flag_pixels, dtype=np.uint8)img = Image.fromarray(array * 255, mode=L)img.show() 完事，感觉不像预期解，但是有没防，怪。 【简单】假面之下的 Flag呃呃，拖进 ida - shift+F12 查看字串 - 甚至第一个就是。 【困难】愤怒喵 NaN~我测，我一拖进 ida，main 函数那图一出来，我去，吓人。还是 shift+F12 查看字串起手，发现两终点： .rodata:000000000000B016\t00000007\tC\tN0N0N0.rodata:000000000000B010\t00000006\tC\tG00D! 可以写出判断终点函数： def is_success(state): return bG00D! in state.posix.dumps(sys.stdout.fileno())def is_fail(state): return bN0N0N0 in state.posix.dumps(sys.stdout.fileno()) 这样不用记地址。按 f5 反编分析 main 函数，发现以下语句： stream = fopen(flag.png, rb);fread(ptr, 1uLL, 0x142uLL, stream); 说明读入了一个大小为 0x142 的 flag.png，可以在 angr 中模拟文件系统，创建一个 flag.png 的符号执行对象： file_size = 0x142symbolic_file = angr.storage.SimFile(flag.png, size=file_size)initial_state.fs.insert(flag.png, symbolic_file) 然后，跑就完事了！ import angrimport sysfrom PIL import Imageimport iodef Go(): path_to_binary = ./mustangr/problem project = angr.Project(path_to_binary) initial_state = project.factory.entry_state() file_size = 0x142 symbolic_file = angr.storage.SimFile(flag.png, size=file_size) initial_state.fs.insert(flag.png, symbolic_file) simulation = project.factory.simgr(initial_state) def is_success(state): return bG00D! in state.posix.dumps(sys.stdout.fileno()) def is_fail(state): return bN0N0N0 in state.posix.dumps(sys.stdout.fileno()) simulation.explore(find=is_success, avoid=is_fail) if simulation.found: solution_state = simulation.found[0] flag_content = solution_state.fs.get(flag.png).concretize() print([+] Success! The flag content is: .format(flag_content)) image = Image.open(io.BytesIO(flag_content)) image.save(output.png) else: print([-] Could not find the solution)if __name__ == __main__: Go() 其实 vmp 那题我也在尝试，已经打了很多函数了，但确实时间不够，没把逻辑看完 QAQ。 小结感谢 NEX 奇妙の小题。","tags":["ctf"]}]